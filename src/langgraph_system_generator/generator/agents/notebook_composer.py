"""Notebook Composer agent for generating notebook cell specifications."""

from __future__ import annotations

from typing import Any, Dict, List

from langchain_openai import ChatOpenAI

from langgraph_system_generator.generator.state import CellSpec, NotebookPlan
from langgraph_system_generator.utils.config import settings


class NotebookComposer:
    """Generates nbformat cell specifications."""

    def __init__(self, model: str | None = None):
        self.llm = ChatOpenAI(model=model or settings.default_model, temperature=0)

    async def compose_notebook(
        self,
        notebook_plan: NotebookPlan,
        workflow_design: Dict[str, Any],
        tools: List[Dict[str, Any]],
        architecture: Dict[str, Any],
    ) -> List[CellSpec]:
        """Generate complete list of notebook cells.

        Args:
            notebook_plan: Notebook structure plan
            workflow_design: Workflow graph design
            tools: Tools specification
            architecture: Architecture selection

        Returns:
            List of CellSpec objects defining all notebook cells
        """
        cells = []

        # Title and intro cells
        cells.extend(
            self._create_intro_cells(notebook_plan, architecture.get("justification"))
        )

        # Installation cells
        cells.extend(self._create_install_cells(tools))

        # Configuration cells
        cells.extend(self._create_config_cells())

        # State definition
        cells.extend(self._create_state_cells(workflow_design))

        # Tool implementations
        if tools:
            cells.extend(self._create_tool_cells(tools))

        # Node implementations
        cells.extend(self._create_node_cells(workflow_design))

        # Graph construction
        cells.extend(self._create_graph_cells(workflow_design))

        # Execution cells
        cells.extend(self._create_execution_cells())

        return cells

    def _create_intro_cells(
        self, plan: NotebookPlan, justification: str | None
    ) -> List[CellSpec]:
        """Create title and introduction cells."""
        title_cell = CellSpec(
            cell_type="markdown",
            content=f"""# {plan.title}

Generated by LangGraph Notebook Foundry

**Architecture**: {plan.architecture_type}  
**Patterns Used**: {', '.join(plan.patterns_used)}
""",
            section="intro",
        )

        overview_cell = CellSpec(
            cell_type="markdown",
            content=f"""## Overview

This notebook implements a LangGraph workflow using the **{plan.architecture_type}** pattern.

### Architecture Justification

{justification or 'Architecture selected based on requirements analysis.'}

### Sections

{chr(10).join([f"1. {section}" for section in plan.sections])}
""",
            section="intro",
        )

        return [title_cell, overview_cell]

    def _create_install_cells(self, tools: List[Dict[str, Any]]) -> List[CellSpec]:
        """Create installation cells."""
        packages = [
            "langgraph",
            "langchain-core",
            "langchain-community",
            "langchain-openai",
        ]

        # Add tool-specific packages
        for tool in tools:
            category = tool.get("category", "")
            if "search" in category.lower():
                packages.append("langchain-community")
            elif "file" in category.lower() or "document" in category.lower():
                packages.append("pypdf")

        install_content = f"""# Install required packages
!pip install -q {' '.join(packages)}"""

        return [
            CellSpec(
                cell_type="markdown",
                content="## Installation\n\nInstall the required packages:",
                section="setup",
            ),
            CellSpec(cell_type="code", content=install_content, section="setup"),
        ]

    def _create_config_cells(self) -> List[CellSpec]:
        """Create configuration cells."""
        config_content = """import os
from getpass import getpass

# Configuration
MODEL = "gpt-4o-mini"
MAX_ITERATIONS = 10

# API Keys
if not os.environ.get("OPENAI_API_KEY"):
    os.environ["OPENAI_API_KEY"] = getpass("Enter OpenAI API Key: ")

if not os.environ.get("ANTHROPIC_API_KEY"):
    os.environ["ANTHROPIC_API_KEY"] = getpass("Enter Anthropic API Key (optional): ")"""

        return [
            CellSpec(
                cell_type="markdown",
                content="## Configuration\n\nSet up API keys and configuration:",
                section="setup",
            ),
            CellSpec(cell_type="code", content=config_content, section="setup"),
        ]

    def _create_state_cells(self, workflow_design: Dict[str, Any]) -> List[CellSpec]:
        """Create state definition cells."""
        state_schema = workflow_design.get("state_schema", {})
        fields = "\n    ".join(
            [f"{name}: str  # {desc}" for name, desc in state_schema.items()]
        )

        state_content = f"""from langgraph.graph import MessagesState


class WorkflowState(MessagesState):
    {fields if fields else "pass"}"""

        return [
            CellSpec(
                cell_type="markdown",
                content="## State Schema\n\nDefine the workflow state:",
                section="state",
            ),
            CellSpec(cell_type="code", content=state_content, section="state"),
        ]

    def _create_tool_cells(self, tools: List[Dict[str, Any]]) -> List[CellSpec]:
        """Create tool implementation cells."""
        cells = [
            CellSpec(
                cell_type="markdown",
                content="## Tools\n\nDefine tools used in the workflow:",
                section="tools",
            )
        ]

        for tool in tools:
            tool_content = f"""# Tool: {tool.get('name')}
# Purpose: {tool.get('purpose')}

def {tool.get('name').lower().replace(' ', '_')}():
    \"\"\"
    {tool.get('purpose')}
    
    Implement the tool logic here.
    \"\"\"
    pass"""

            cells.append(
                CellSpec(cell_type="code", content=tool_content, section="tools")
            )

        return cells

    def _create_node_cells(self, workflow_design: Dict[str, Any]) -> List[CellSpec]:
        """Create node implementation cells."""
        cells = [
            CellSpec(
                cell_type="markdown",
                content="## Nodes\n\nImplement workflow nodes:",
                section="nodes",
            )
        ]

        nodes = workflow_design.get("nodes", [])
        for node in nodes:
            node_name = node.get("name", "unknown")
            node_purpose = node.get("purpose", "")

            node_content = f"""def {node_name}_node(state: WorkflowState) -> WorkflowState:
    \"\"\"
    {node_purpose}
    
    Implement the node logic here.
    \"\"\"
    # Implement node logic
    return state"""

            cells.append(
                CellSpec(cell_type="code", content=node_content, section="nodes")
            )

        return cells

    def _create_graph_cells(self, workflow_design: Dict[str, Any]) -> List[CellSpec]:
        """Create graph construction cells."""
        entry_point = workflow_design.get("entry_point", "start")

        graph_content = f"""from langgraph.graph import END, START, StateGraph
from langgraph.checkpoint.memory import MemorySaver
from langgraph.types import Command

# Create graph
workflow = StateGraph(WorkflowState)
memory = MemorySaver()

# Add nodes (add your node implementations here)
# workflow.add_node("node_name", node_name_node)

# Connect start to entry point
workflow.add_edge(START, "{entry_point}")

# Add edges (define your workflow edges here)
# workflow.add_edge("node_a", "node_b")

# Compile graph
graph = workflow.compile(checkpointer=memory)"""

        return [
            CellSpec(
                cell_type="markdown",
                content="## Graph Construction\n\nBuild the LangGraph workflow:",
                section="graph",
            ),
            CellSpec(cell_type="code", content=graph_content, section="graph"),
        ]

    def _create_execution_cells(self) -> List[CellSpec]:
        """Create execution cells."""
        exec_content = """# Execute the workflow with a durable thread
config = {"configurable": {"thread_id": "lnf-demo-thread"}}
initial_state: WorkflowState = {
    "messages": [],
    # Configure additional workflow state fields as needed
}

print("Streaming state updates:")
for step in graph.stream(initial_state, config, stream_mode="updates"):
    print(step)

final_state = graph.invoke(initial_state, config)
print(final_state)"""

        return [
            CellSpec(
                cell_type="markdown",
                content="## Execution\n\nRun the workflow:",
                section="execution",
            ),
            CellSpec(cell_type="code", content=exec_content, section="execution"),
        ]
