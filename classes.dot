digraph "classes" {
rankdir=BT
charset="utf-8"
"src.langgraph_system_generator.generator.agents.architecture_selector.ArchitectureSelector" [color="black", fontcolor="black", label=<{ArchitectureSelector|docs_retriever : DocsRetriever \| None<br ALIGN="LEFT"/>llm : ChatOpenAI<br ALIGN="LEFT"/>|select_architecture(constraints: List[Constraint], docs_context: List[DocSnippet]): Dict[str, Any]<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.langgraph_system_generator.generator.state.CellSpec" [color="black", fontcolor="black", label=<{CellSpec|cell_type : Optional[str]<br ALIGN="LEFT"/>content : Optional[str]<br ALIGN="LEFT"/>metadata : Optional[Dict[str, Any]]<br ALIGN="LEFT"/>section : Optional[str]<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"src.langgraph_system_generator.generator.state.Constraint" [color="black", fontcolor="black", label=<{Constraint|priority : Optional[int]<br ALIGN="LEFT"/>type : Optional[str]<br ALIGN="LEFT"/>value : Optional[str]<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"src.langgraph_system_generator.patterns.critique_loops.CritiqueLoopPattern" [color="black", fontcolor="black", label=<{CritiqueLoopPattern|<br ALIGN="LEFT"/>|generate_complete_example(task_description: str, criteria: Optional[List[str]], max_revisions: int): str<br ALIGN="LEFT"/>generate_conditional_edge_code(max_revisions: int, min_quality_score: float): str<br ALIGN="LEFT"/>generate_critique_node_code(criteria: Optional[List[str]], llm_model: str, use_structured_output: bool): str<br ALIGN="LEFT"/>generate_generation_node_code(task_description: str, llm_model: str): str<br ALIGN="LEFT"/>generate_graph_code(max_revisions: int, min_quality_score: float): str<br ALIGN="LEFT"/>generate_revise_node_code(llm_model: str): str<br ALIGN="LEFT"/>generate_state_code(additional_fields: Optional[Dict[str, str]]): str<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.langgraph_system_generator.generator.state.DocSnippet" [color="black", fontcolor="black", label=<{DocSnippet|content : Optional[str]<br ALIGN="LEFT"/>heading : Optional[str]<br ALIGN="LEFT"/>relevance_score : Optional[float]<br ALIGN="LEFT"/>source : Optional[str]<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"src.langgraph_system_generator.rag.indexer.DocsIndexer" [color="black", fontcolor="black", label=<{DocsIndexer|DOCS_URLS<br ALIGN="LEFT"/>LANGCHAIN_AGENTS_URLS : list<br ALIGN="LEFT"/>LANGCHAIN_CHAINS_URLS : list<br ALIGN="LEFT"/>LANGCHAIN_CORE_URLS : list<br ALIGN="LEFT"/>LANGCHAIN_RAG_URLS : list<br ALIGN="LEFT"/>LANGGRAPH_ADVANCED_URLS : list<br ALIGN="LEFT"/>LANGGRAPH_CORE_URLS : list<br ALIGN="LEFT"/>LANGGRAPH_PATTERNS_URLS : list<br ALIGN="LEFT"/>LANGGRAPH_STATE_URLS : list<br ALIGN="LEFT"/>chunk_overlap : int<br ALIGN="LEFT"/>chunk_size : int<br ALIGN="LEFT"/>request_timeout : float<br ALIGN="LEFT"/>urls : list<br ALIGN="LEFT"/>|chunk_documents(docs: List[Document]): List[Document]<br ALIGN="LEFT"/>scrape_docs(): List[Document]<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.langgraph_system_generator.rag.retriever.DocsRetriever" [color="black", fontcolor="black", label=<{DocsRetriever|vector_store_manager : VectorStoreManager<br ALIGN="LEFT"/>|retrieve(query: str, k: int): List[RetrievedSnippet]<br ALIGN="LEFT"/>retrieve_for_pattern(pattern_name: str): List[RetrievedSnippet]<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.langgraph_system_generator.rag.cache.DocumentCache" [color="black", fontcolor="black", label=<{DocumentCache|cache_file<br ALIGN="LEFT"/>cache_path : Path<br ALIGN="LEFT"/>|exists(): bool<br ALIGN="LEFT"/>load_documents(): List[Document]<br ALIGN="LEFT"/>save_documents(documents: List[Document]): None<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.langgraph_system_generator.cli.GenerationArtifacts" [color="black", fontcolor="black", label=<{GenerationArtifacts|manifest : Dict[str, Any]<br ALIGN="LEFT"/>manifest_path : str<br ALIGN="LEFT"/>mode : Literal<br ALIGN="LEFT"/>output_dir : str<br ALIGN="LEFT"/>prompt : str<br ALIGN="LEFT"/>result : Dict[str, Any]<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"src.langgraph_system_generator.api.server.GenerationRequest" [color="black", fontcolor="black", label=<{GenerationRequest|agent_type : Optional[str]<br ALIGN="LEFT"/>custom_endpoint : Optional[str]<br ALIGN="LEFT"/>document_loader : Optional[str]<br ALIGN="LEFT"/>formats : Optional[list[str]]<br ALIGN="LEFT"/>graph_style : Optional[str]<br ALIGN="LEFT"/>max_tokens : Optional[int]<br ALIGN="LEFT"/>memory_config : Optional[str]<br ALIGN="LEFT"/>mode : Optional[GenerationMode]<br ALIGN="LEFT"/>model : Optional[str]<br ALIGN="LEFT"/>output_dir : Optional[str]<br ALIGN="LEFT"/>preset : Optional[str]<br ALIGN="LEFT"/>prompt : Optional[str]<br ALIGN="LEFT"/>retriever_type : Optional[str]<br ALIGN="LEFT"/>temperature : Optional[float]<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"src.langgraph_system_generator.api.server.GenerationResponse" [color="black", fontcolor="black", label=<{GenerationResponse|error : Optional[str]<br ALIGN="LEFT"/>manifest : Optional[Dict[str, Any]]<br ALIGN="LEFT"/>manifest_path : Optional[str]<br ALIGN="LEFT"/>mode : Optional[str]<br ALIGN="LEFT"/>output_dir : Optional[str]<br ALIGN="LEFT"/>prompt : Optional[str]<br ALIGN="LEFT"/>success : bool<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"src.langgraph_system_generator.generator.state.GeneratorState" [color="black", fontcolor="black", label=<{GeneratorState|architecture_justification : str<br ALIGN="LEFT"/>architecture_type : Optional[str]<br ALIGN="LEFT"/>artifacts_manifest : Dict[str, str]<br ALIGN="LEFT"/>constraints : Annotated[List[Constraint], operator.add]<br ALIGN="LEFT"/>docs_context : Annotated[List[DocSnippet], operator.add]<br ALIGN="LEFT"/>error_message : Optional[str]<br ALIGN="LEFT"/>generated_cells : Annotated[List[CellSpec], operator.add]<br ALIGN="LEFT"/>generation_complete : bool<br ALIGN="LEFT"/>notebook_plan : Optional[NotebookPlan]<br ALIGN="LEFT"/>qa_reports : List[QAReport]<br ALIGN="LEFT"/>repair_attempts : int<br ALIGN="LEFT"/>selected_patterns : Dict[str, Any]<br ALIGN="LEFT"/>tools_plan : Optional[List[Dict[str, Any]]]<br ALIGN="LEFT"/>uploaded_files : Optional[List[str]]<br ALIGN="LEFT"/>user_prompt : str<br ALIGN="LEFT"/>workflow_design : Optional[Dict[str, Any]]<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"src.langgraph_system_generator.generator.agents.graph_designer.GraphDesigner" [color="black", fontcolor="black", label=<{GraphDesigner|llm : ChatOpenAI<br ALIGN="LEFT"/>|design_workflow(architecture: Dict[str, Any], constraints: List[Constraint]): Dict[str, Any]<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.langgraph_system_generator.notebook.manuscript_docx.ManuscriptDOCXGenerator" [color="black", fontcolor="black", label=<{ManuscriptDOCXGenerator|font_name : str<br ALIGN="LEFT"/>font_size : int<br ALIGN="LEFT"/>line_spacing : float<br ALIGN="LEFT"/>|create_manuscript(title: str, author: str \| None, chapters: Sequence[Dict[str, Any]] \| None, output_path: str \| Path, include_title_page: bool): str<br ALIGN="LEFT"/>create_notebook_manuscript(notebook_cells: Sequence[Dict[str, Any]], output_path: str \| Path, title: str \| None, author: str \| None): str<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.langgraph_system_generator.notebook.manuscript_pdf.ManuscriptPDFGenerator" [color="black", fontcolor="black", label=<{ManuscriptPDFGenerator|body_style : ParagraphStyle<br ALIGN="LEFT"/>chapter_style : ParagraphStyle<br ALIGN="LEFT"/>code_style : ParagraphStyle<br ALIGN="LEFT"/>font_name : str<br ALIGN="LEFT"/>font_size : int<br ALIGN="LEFT"/>page_size : tuple<br ALIGN="LEFT"/>section_style : ParagraphStyle<br ALIGN="LEFT"/>styles : StyleSheet1<br ALIGN="LEFT"/>subsection_style : ParagraphStyle<br ALIGN="LEFT"/>|create_manuscript(title: str, chapters: Sequence[Dict[str, Any]], output_path: str \| Path, author: str \| None, include_title_page: bool): str<br ALIGN="LEFT"/>create_notebook_manuscript(notebook_cells: Sequence[Dict[str, Any]], output_path: str \| Path, title: str \| None, author: str \| None): str<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.langgraph_system_generator.generator.agents.notebook_composer.NotebookComposer" [color="black", fontcolor="black", label=<{NotebookComposer|llm : ChatOpenAI<br ALIGN="LEFT"/>|compose_notebook(notebook_plan: NotebookPlan, workflow_design: Dict[str, Any], tools: List[Dict[str, Any]], architecture: Dict[str, Any]): List[CellSpec]<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.langgraph_system_generator.notebook.composer.NotebookComposer" [color="black", fontcolor="black", label=<{NotebookComposer|colab_friendly : bool<br ALIGN="LEFT"/>|build_notebook(cells: Sequence[CellSpec], ensure_minimum_sections: bool): NotebookNode<br ALIGN="LEFT"/>write(notebook: NotebookNode, path: str \| Path): str<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.langgraph_system_generator.notebook.exporters.NotebookExporter" [color="black", fontcolor="black", label=<{NotebookExporter|<br ALIGN="LEFT"/>|export_ipynb(notebook: nbformat.NotebookNode, path: str \| Path): str<br ALIGN="LEFT"/>export_notebook_to_docx(notebook: nbformat.NotebookNode, output_path: str \| Path, title: str \| None): str<br ALIGN="LEFT"/>export_to_html(notebook: nbformat.NotebookNode, output_path: str \| Path): str<br ALIGN="LEFT"/>export_to_pdf(notebook_path: str \| Path, output_path: str \| Path, method: str): str<br ALIGN="LEFT"/>export_zip(notebook: nbformat.NotebookNode, zip_path: str \| Path, extra_files: Sequence[str \| os.PathLike[str]] \| None, notebook_name: str): str<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.langgraph_system_generator.generator.state.NotebookPlan" [color="black", fontcolor="black", label=<{NotebookPlan|architecture_type : Optional[str]<br ALIGN="LEFT"/>cell_count_estimate : Optional[int]<br ALIGN="LEFT"/>patterns_used : Optional[List[str]]<br ALIGN="LEFT"/>sections : Optional[List[str]]<br ALIGN="LEFT"/>title : Optional[str]<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"src.langgraph_system_generator.qa.repair.NotebookRepairAgent" [color="black", fontcolor="black", label=<{NotebookRepairAgent|DEFAULT_MAX_ATTEMPTS : int<br ALIGN="LEFT"/>max_attempts : int<br ALIGN="LEFT"/>validator : NotebookValidator<br ALIGN="LEFT"/>|get_repair_summary(qa_reports: List[QAReport]): Dict[str, Any]<br ALIGN="LEFT"/>repair_notebook(notebook_path: str \| Path, qa_reports: List[QAReport], attempt: int): tuple[bool, List[QAReport]]<br ALIGN="LEFT"/>should_retry(qa_reports: List[QAReport], attempt: int): bool<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.langgraph_system_generator.qa.validators.NotebookValidator" [color="black", fontcolor="black", label=<{NotebookValidator|PLACEHOLDER_PATTERNS : list<br ALIGN="LEFT"/>REQUIRED_IMPORTS : list<br ALIGN="LEFT"/>REQUIRED_SECTIONS : list<br ALIGN="LEFT"/>|check_graph_compiles(notebook_path: str \| Path): QAReport<br ALIGN="LEFT"/>check_imports_present(notebook_path: str \| Path, required_imports: Optional[List[str]]): QAReport<br ALIGN="LEFT"/>check_no_placeholders(notebook_path: str \| Path): QAReport<br ALIGN="LEFT"/>check_required_sections(notebook_path: str \| Path, required_sections: Optional[List[str]]): QAReport<br ALIGN="LEFT"/>validate_all(notebook_path: str \| Path): List[QAReport]<br ALIGN="LEFT"/>validate_json_structure(notebook_path: str \| Path): QAReport<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.langgraph_system_generator.generator.agents.qa_repair_agent.QARepairAgent" [color="black", fontcolor="black", label=<{QARepairAgent|llm : ChatOpenAI<br ALIGN="LEFT"/>|repair(cells: List[CellSpec], qa_reports: List[QAReport]): List[CellSpec]<br ALIGN="LEFT"/>validate(cells: List[CellSpec]): List[QAReport]<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.langgraph_system_generator.generator.state.QAReport" [color="black", fontcolor="black", label=<{QAReport|check_name : Optional[str]<br ALIGN="LEFT"/>message : Optional[str]<br ALIGN="LEFT"/>passed : Optional[bool]<br ALIGN="LEFT"/>suggestions : Optional[List[str]]<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"src.langgraph_system_generator.generator.agents.requirements_analyst.RequirementsAnalyst" [color="black", fontcolor="black", label=<{RequirementsAnalyst|llm : ChatOpenAI<br ALIGN="LEFT"/>|analyze(prompt: str): List[Constraint]<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.langgraph_system_generator.rag.retriever.RetrievedSnippet" [color="black", fontcolor="black", label=<{RetrievedSnippet|content : str<br ALIGN="LEFT"/>heading : Optional[str]<br ALIGN="LEFT"/>relevance_score : float<br ALIGN="LEFT"/>source : str<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"src.langgraph_system_generator.patterns.router.RouterPattern" [color="black", fontcolor="black", label=<{RouterPattern|<br ALIGN="LEFT"/>|generate_complete_example(routes: List[str], route_purposes: Optional[Dict[str, str]]): str<br ALIGN="LEFT"/>generate_graph_code(routes: List[str], entry_point: str, use_conditional_edges: bool): str<br ALIGN="LEFT"/>generate_route_node_code(route_name: str, route_purpose: str, llm_model: str): str<br ALIGN="LEFT"/>generate_router_node_code(routes: List[str], llm_model: str, use_structured_output: bool): str<br ALIGN="LEFT"/>generate_state_code(additional_fields: Optional[Dict[str, str]]): str<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.langgraph_system_generator.utils.config.Settings" [color="black", fontcolor="black", label=<{Settings|anthropic_api_key : Optional[str]<br ALIGN="LEFT"/>default_budget_tokens : Optional[int]<br ALIGN="LEFT"/>default_model : Optional[str]<br ALIGN="LEFT"/>langsmith_api_key : Optional[str]<br ALIGN="LEFT"/>langsmith_project : Optional[str]<br ALIGN="LEFT"/>max_repair_attempts : Optional[int]<br ALIGN="LEFT"/>model_config : SettingsConfigDict<br ALIGN="LEFT"/>openai_api_key : Optional[str]<br ALIGN="LEFT"/>vector_store_path : Optional[str]<br ALIGN="LEFT"/>vector_store_type : Optional[str]<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"src.langgraph_system_generator.patterns.subagents.SubagentsPattern" [color="black", fontcolor="black", label=<{SubagentsPattern|<br ALIGN="LEFT"/>|generate_complete_example(subagents: List[str], subagent_descriptions: Optional[Dict[str, str]]): str<br ALIGN="LEFT"/>generate_graph_code(subagents: List[str], max_iterations: int): str<br ALIGN="LEFT"/>generate_state_code(additional_fields: Optional[Dict[str, str]]): str<br ALIGN="LEFT"/>generate_subagent_code(agent_name: str, agent_description: str, llm_model: str, include_tools: bool): str<br ALIGN="LEFT"/>generate_supervisor_code(subagents: List[str], subagent_descriptions: Optional[Dict[str, str]], llm_model: str, use_structured_output: bool): str<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.langgraph_system_generator.generator.agents.toolchain_engineer.ToolchainEngineer" [color="black", fontcolor="black", label=<{ToolchainEngineer|llm : ChatOpenAI<br ALIGN="LEFT"/>|plan_tools(workflow_design: Dict[str, Any], constraints: List[Constraint]): List[Dict[str, Any]]<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"src.langgraph_system_generator.rag.embeddings.VectorStoreManager" [color="black", fontcolor="black", label=<{VectorStoreManager|embeddings : OpenAIEmbeddings<br ALIGN="LEFT"/>store_path : str<br ALIGN="LEFT"/>vector_store : Optional[FAISS]<br ALIGN="LEFT"/>|create_index(documents: List[Document]): FAISS<br ALIGN="LEFT"/>index_exists(): bool<br ALIGN="LEFT"/>load_index(): FAISS<br ALIGN="LEFT"/>load_or_create(documents: List[Document]): FAISS<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
}
